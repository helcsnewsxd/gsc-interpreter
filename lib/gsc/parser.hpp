#pragma once

#include "gsc/expr.hpp"
#include "gsc/stmt.hpp"
#include "gsc/token.hpp"
#include <memory>
#include <stdexcept>
#include <vector>

/** @class Parser
 * @brief Parser module for the GSC programming language.
 *
 * Parser is responsible for parsing the tokens generated by the Scanner
 * and constructing an abstract syntax tree (AST) from them.
 */
class Parser {
private:
  /** @internal
   * @class ParseError
   * @brief Exception class for parser errors.
   *
   * @note This exception is thrown when the parser encounters an error during
   * parsing.
   * @note It inherits from std::runtime_error to provide a standard error
   * interface.
   */
  struct ParseError : public std::runtime_error {
    using std::runtime_error::runtime_error;
  };

  const std::vector<Token> &tokens;
  int current = 0;

  std::vector<std::shared_ptr<Stmt>> block();
  std::shared_ptr<Stmt> declaration();
  std::shared_ptr<Stmt> statement();
  std::shared_ptr<Stmt> printStatement();
  std::shared_ptr<Stmt> ifStatement();
  std::shared_ptr<Stmt> whileStatement();
  std::shared_ptr<Stmt> forStatement();
  std::shared_ptr<Stmt> varDeclaration();
  std::shared_ptr<Stmt> expressionStatement();
  std::shared_ptr<Expr> assignment();
  std::shared_ptr<Expr> orLogical();
  std::shared_ptr<Expr> andLogical();
  std::shared_ptr<Expr> expression();
  std::shared_ptr<Expr> equality();
  std::shared_ptr<Expr> comparison();
  std::shared_ptr<Expr> term();
  std::shared_ptr<Expr> factor();
  std::shared_ptr<Expr> unary();
  std::shared_ptr<Expr> primary();

  template <class... T> bool match(T... types);
  bool check(TokenType type) const;
  bool isAtEnd() const;

  Token consume(TokenType type, std::string_view message);
  Token advance();
  Token peek() const;
  Token previous() const;

  /** @internal
   * @brief Throws a ParseError with the given token and message.
   *
   * @param token The token where the error occurred.
   * @param message The error message to display.
   * @return ParseError The thrown ParseError exception.
   */
  ParseError error(const Token &token, std::string_view message);

  /** @internal
   * @brief Synchronizes the parser state after an error.
   *
   * This function skips tokens until it finds a token that can be safely
   * resumed, allowing the parser to continue parsing after an error.
   */
  void synchronize();

public:
  /** @brief Constructs a Parser object.
   *
   * @param tokens The vector of tokens to parse.
   */
  Parser(const std::vector<Token> &tokens);

  /** @brief Parses the tokens and returns a vector of statements.
   *
   * This function processes the tokens and constructs an abstract syntax tree
   * (AST) represented as a vector of statements.
   *
   * @return std::vector<std::shared_ptr<Stmt>> A vector of shared pointers to
   * the parsed statements.
   */
  std::vector<std::shared_ptr<Stmt>> parse();
};
